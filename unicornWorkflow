/* Emulating Firmware */
Write a Unicorn program that executes a firmware
   Memory Mapping
      - ARM defines a standardized address space of 4GB
         - Code area starts at 0x00000000 and aliases 0x08000000 (routine at 0x080016DC and be accessed from 0x000016DC)
            - Includes SP, Reset, Vector Table
            -> Refer to Ghidra/Radare2 to get address ranges for now. May be able to automate this later
         - MMIO ranges 0x40000000 - 0x5fffffff 
         - Stack / Heap (0x200xx000 - 0x20000000)
         	- Resides in SRAM where .data (VMA) and .bss are
         - 	
         	
   MMIO Callbacks 
      - // TODO: Document how this is done. 
   
   User Configurations
      - Think about what needs to be configured by the user specifically to configure their emulator
      Peripherals
         -> User gives
            1) Give address of a peripheral (e.g. USART1)
            2) Give the register address a particular bit functionality (e.g. USART1->CR1 mapped to USART1 enable)
            3) Give the specific bit in that register that triggers that functionality
            
            - Registers can be 8 bit, 32 bit, other? (check for 16 bit registers ... just keep reading on other periphs)
               - How do we emulate for 8 bit registers? (How does fw interact with 8 bit)
                  - I want to know if we can keep 32 bit or if we need to have two different modes for 8 bit and 32 bit
                     (May very well need an 8 bit mode.)
                     - How do 32 bit UARTs compare to each other and how do 8 bit  UARTS compare to each other



/* Firmware Testing */                     
Testing Emulator with Real Firmware
   Researching Firmware to Test
      - FW details
         - Should allow ELF or Raw Binary
         - Should be for ARM Cortex-M devices. (for now)        
      - Where to find FW?
	     - Find FW that other papers tested 
	        -> Find all the papers that Austin sent last summer                  
		 - How did other papers find FW?
		    - Unit Tests
		       - They found examples from OS libraries. 
		    - Real Firmware
		       - Lots of Github source code that was compiled with some IDE
		       - binaries are available as ARM ELF files. No, raw binaries.   
		       
		          		          
   Testing Peripherals
      - Which peripherals to test?
         - Most popular?, P2IM mentions: SPI, USART, I2C, GPIO, ADC, DAC, TIMER, PWM
   		 -> Any, just want to see if the SR values pass.
   		     
   Testing Binaries
      - What form does binary need to be in? ELF or Raw Binary?
         - P2IM uses ELF files         
      -> Want to be able to support ELF or raw binaries. (ELF first)
         ELF Files
            -> Could execute ELF by just providing it
               -> Could gather ELF info and execute from entry point and auto generate memory map with Python script.
               
            -> Can additionally allow user to manually execute points of interest like with Raw binary option below. 
               
         Raw Binary 
            -> Will require manual intervention from user to provide start/stop points, processor state,
              memory map, etc.


   // Things TODO in order for FW execution to work
   TODO

      1) [ ] Init SP/FP given ELF file (ARM ELF for Linux and barebones MCU) and Raw Binary
                - Need to ELF file's code and SRAM regions for this to work.
      2) [x] Map in memory the generic flash/SRAM regions for Cortex-M devices (so it doesn't need to be automated from ELF. Reduces complexity)
      3) [ ] Read multiple data sections from ELF and store them all. 
      4) [ ] For Stripped ELFs/Raw binaries, Need an automated way to read code and data sections into emulator by having user provide the 
             address and size of these sections. 
    
      1) Init SP/FP given ELF file (ARM ELF for Linux and barebones MCU) and Raw Binary
      2) 

   
   // Things Completed from list above
   Done   
      1) 

	  2) Map in memory the generic flash/SRAM regions for Cortex-M devices (so it doesn't need to be automated from ELF. Reduces complexity) 

   Queries
      1) [IMPORTANT] Does the memory map have to be specific to MCU? Or can we make it expand the range specified for ARM Cortex-M MCUs. 
         See [mem_map] in emulatorConfig.toml as example.
         Is there a generic Cortex-M manual for all Cortex-M devices? Probably, not. Can read them individually though. 
      2) [IMPORTANT] How will we handle Raw binaries and stripped ELF files? 
         Can handle ELF files with symbols first, then move on to the latter.    



/* Compiling the Emulators */
// TODO: Eventually want to make my added files apart of the unicorn library
gcc EmulateUart.c emulatorConfig.c toml.c tester.c -lunicorn -lpthread


/* Generating ELF file: Compiling the Source Code to emulate */
arm-none-eabi-gcc -specs=nosys.specs SimpleUart.c -o SimpleUart.elf
or
arm-none-eabi-gcc -specs=nosys.specs PollingUart.c -o PollingUart.elf

/* Compiling and Making Unicorn */        
Command to install and compile Unicorn
./make.sh (assumes config file only makes for ARM)
sudo ./make.sh install

/* Setting Unicorn Library path for GCC */
1.) Undefined References to pthread functions
    - place lpthread after lunicorn
2.) Can't find libunicorn.so.1 when running executable
    - Run 'ldd a.out' to see what libraries are found and where
    - Add the path of libunicorn.so.1 to GCC library path @ /etc/ld.so.conf.d/x86_64-linux-gnu.conf
    - run sudo ldconfig to update library cache
  
/* Getting TOML to work with CPEA */
C Parser
	1) Include toml.h and toml.c files.
Python3 TOML Parser
	tomlkit
	1) pip install tomlkit 

/* Getting ELF Parsing to work with CPEA */
Python3 ELF Parser
	pyelftools
	1) pip install pyelftool  
  
  
/* Deprecated methods for getting Raw Binary to execute */ 

/* Producing Hex String from assembly */   
Assembly to Hex String
rasm2 -a arm -C -f arm.asm

/* Manually producing binaries to emulate */
Compiling C code to 32-bit ARM
To Produce Assembly:
	arm-none-eabi-gcc -marm -S (--specs=nosys.specs) SimplePollUart.c -o SimplePollUart.s
    		  	               (optional, may want to try)
To Assemble:
	arm-none-eabi-as -o SimplePollUart.o SimplePollUart.s

To Compile,assemble,link
	arm-none-eabi-gcc -marm SimplePoll_uart.c

To Print Opcode
   - Radare2 to print out opcode. Add '00' to end of file to add terminator.
      - Go to entry point with command
         'p8 [N]' to print hexpair list for N bytes and remember to add '00' string terminator
         
To Convert to Raw Binary
    - 'xxd -r -p input.opcode output.bin' to get raw binary
	  - Read this into Unicorn and store in char array. :)
	 

