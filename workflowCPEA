/* Running qemu full system emulation */
./qemu-system-arm -display none
gdb --args ./qemu-system-arm --display none

/* Other Project Names */
CPEFF - Configurable Peripheral Emulator and Fuzzing Framework
CPEF - Configurable Peripheral Emulator and Fuzzer
CPEQ - Configurable Peripheral Emulator for QEMU

/* Emulating Firmware */
Write a Unicorn program that executes a firmware
   Memory Mapping
      - ARM defines a standardized address space of 4GB
         - Code area starts at 0x00000000 and aliases 0x08000000 (routine at 0x080016DC and be accessed from 0x000016DC)
            - Includes SP, Reset, Vector Table
            -> Refer to Ghidra/Radare2 to get address ranges for now. May be able to automate this later
         - MMIO ranges 0x40000000 - 0x5fffffff 
         - Stack / Heap (0x200xx000 - 0x20000000)
         	- Resides in SRAM where .data (VMA) and .bss are
         - 	
         	
   MMIO Callbacks 
      - // TODO: Document how this is done. 
   
   User Configurations
      - Think about what needs to be configured by the user specifically to configure their emulator
      Peripherals
         -> User gives
            1) Give address of a peripheral (e.g. USART1)
            2) Give the register address a particular bit functionality (e.g. USART1->CR1 mapped to USART1 enable)
            3) Give the specific bit in that register that triggers that functionality
            
            - Registers can be 8 bit, 32 bit, other? (check for 16 bit registers ... just keep reading on other periphs)
               - How do we emulate for 8 bit registers? (How does fw interact with 8 bit)
                  - I want to know if we can keep 32 bit or if we need to have two different modes for 8 bit and 32 bit
                     (May very well need an 8 bit mode.)
                     - How do 32 bit UARTs compare to each other and how do 8 bit  UARTS compare to each other



/* Firmware Testing */                     
Testing Emulator with Real Firmware
   Researching Firmware to Test
      - FW details
         - Should allow ELF or Raw Binary
         - Should be for ARM Cortex-M devices. (for now)        
      - Where to find FW?
	     - Find FW that other papers tested 
	        -> Find all the papers that Austin sent last summer                  
		 - How did other papers find FW?
		    - Unit Tests
		       - They found examples from OS libraries. 
		    - Real Firmware
		       - Lots of Github source code that was compiled with some IDE
		       - binaries are available as ARM ELF files. No, raw binaries.   
		       
		          		          
   Testing Peripherals
      - Which peripherals to test?
         - Most popular?, P2IM mentions: SPI, USART, I2C, GPIO, ADC, DAC, TIMER, PWM
   		 -> Any, just want to see if the SR values pass.
   		     
   Testing Binaries
      - What form does binary need to be in? ELF or Raw Binary?
         - P2IM uses ELF files         
      -> Want to be able to support ELF or raw binaries. (ELF first)
         ELF Files
            -> Could execute ELF by just providing it
               -> Could gather ELF info and execute from entry point and auto generate memory map with Python script.
               
            -> Can additionally allow user to manually execute points of interest like with Raw binary option below. 
               
         Raw Binary 
            -> Will require manual intervention from user to provide start/stop points, processor state,
              memory map, etc. 


/* Todo List NEEDS REVISED */
[x] - Complete
[p] - In Progress
[s] - Skipping
[ ] - Not Started

   TODO     
      Integrating into QEMU
      1) [x] Save backup of our current code and document what it does and doesn't do.
      2) [x] Make new branch for qemu-integration and get qemu code base into it.
                - No submodule, pulling. Instead, downloaded and copied it into repo.
      3) [x] Move files into repo that won't be compiled with qemu source
                - Python scripts, firmware, etc.            
      4) [x] Figure out how to build QEMU.
      SEE "Building QEMU on Ubuntu 20.04" BELOW FOR MORE.
      
      General Category /* Old Unicorn Implementation: DEPRECATED */
      1) [p] Init SP/FP given ELF file (ARM ELF for Linux and barebones MCU) and Raw Binary
                - Need to test with an actual extracted Raw Binary.
      2) [x] Map in entire memory region for Cortex-M devices (so it doesn't need to be automated from ELF. Reduces complexity)
      3) [x] Read multiple data sections from ELF and store them all. 
      4) [ ] To avoid mapping 4GB by default: For memory mapping, could try and map certain memory sections during execution.
             - Can map memory for each MMIO we do configure.
             - Can map memory for each unmapped MMIO we don't configure.
             - Can map memory for the start addr and size of our FW image.
             - Can map other accessed unmapped regions on the fly. (unkown scenarios with this solution.)
      5) [ ] Need to give user option to start/stop ELFs/Raw Binaries from anywhere, instead of the default reset handler.
      6) [x] Need to let user set SR bits at certain addresses that SRs are accessed.
             (SR ideal bit values can change over course of FW execution.)
             Can implement this as callback for 1) Every instruction execution 2) Every mapped MMIO access
             Bug Checks             
      7) [ ] Allow user to set starting address of FW. Currently assumed to start at 0, but could start at 0x0800 0000 for example.
             FW will reference data according to where it's located virtually, so need to account for this.  
             See map_memory() and flash_init().
                                                                  
      Interrupts                                                                  
      1) [P] Find how to detect which interrupts are enabled in FW via NVIC or vector table.
                Can issue a callback for anytime ISER/ICER are accessed. 
                Need to emulate these registers to some degree and keep a list of enabled interrupts
                based on how ISER and ICER are written to. P2IM used some NVIC_PENDING register to help fire? look into it
                                                                     
      2) [P] Create an interrupt firing strategy for the interrupts that are enabled.
                Want to figure out why RTC isn't being enabled.
                Or, why we get stuck in an infinite loop.

      Debugging
      1) [ ] Find a way for user to step through code line by line. (GDB stubs an option?)
             Want something to work for ELFs, Raw Binaries, etc.
      
      Automation
      1) [x] Implement "Generic" peripherals with generic flags
      2) [x] Add option for user to change polarity of a SR bit so they can set default
             value to '0' or '1' (observed that status bit can be checked to be 0 or 1).
             Can add a "Value =" key, for which '0' and '1' are the only values. 
      3) [x] Add option for user to specify the SR access address that they want the value to take effect at.
             - Automate from python: Add to inline table
             - Parse in C: Need to set SR values in callback when address is accessed.
             Could infer acceptable values for SR bits for polling scenarios, but there may be other scenarios where instead of polling (hanging),
             FW could instead crash upon an incorrect SR bit. Therefore, will have user manually specify bits at certain addresses for this reason. 
      4) [ ] Add a count for number of generic flags the user may want to set for any given peripheral.        



      Misc
      1) [x] Find if uc_mem_map() allocates space in host memory. Use valgrind to check.      
                              
      Bugs (or potential problems)
      1) [x] Memory Leak somewhere related to TOML.
      2) [x] Stack Smashing error in mmioConfig().
      3) [x] SR "bit" value in config isn't confined to SR limits. Can be any number.
      4) [x] Init registers in MMIO struct to 0, perhaps other MMIO members as well. 
      5) [x] Get min/max addr for each module in parseKeys(). Need it for determining which peripheral we've accessed. 
      6) [x] memory leak related to the root toml table                    
      
   Queries
      1) [HANDLED] Does the memory map have to be specific to MCU? Or can we make it expand the range specified for ARM Cortex-M MCUs. 
         See [mem_map] in emulatorConfig.toml as example.
         Used ARMv7 Arch reference manual.  
      2) [HANDLED] How will we handle Raw binaries and stripped ELF files? 
         Stripped ELF files should still have LOAD program headers, so they'd be the same as 
         non-stripped ELFs. Raw binaries might be the same as the output we get from extracting
         LOAD sections from the ELF... so might be finished on that front. Just need to double check.                    
      3) [CURIOUS] In what context are dynamically linked ELFs used? Currently, we only create binary from statically linked.
                   Would we need to create binary from dynamically linked?

/*****************
    QEMU World
******************/

/* Building QEMU on Ubuntu 20.04 */
1) [x] Installations to build 
            sudo apt-get install libnfs-dev libiscsi-dev from QEMU's build page
            sudo apt-get install libglib2.0-dev
            sudo apt-get install libpixman-1-dev

2) [x] Clone QEMU. Get Submodule Code. Remove repositories for QEMU and submodules, but keep their relevant code.
       1) [x] Remove qemu/ as repo. (rm -r .git)
       2) [x] Remove submodules from qemu/ (rm .gitmodules AND rm .git for each submodule)
                 meson/, capstone/, dtc/, slirp/, roms/., tests/fp/. 
                 
3) [p] Building
       1) [x] Make 'build/' directory and enter it.  
       2) [x] Run './configure --enable-debug --target-list=arm-softmmu' to only build files for ARM.
       3) [p] Run 'make.' (Very Lengthy Process to build the binaries. Would like to lessen the time by building only what we need.)
              // TODO: Can (probably) delete files we don't need care to compile.
       4) [x] Need to figure out how to include my own files into the build.
       5) SEE 4.2) for adding own files. 

/* Getting qemu to execute code */
4) [p] Executing 'qemu-arm-softmmu'  
       NOTE: Would repeat 4.2 to create machine for other architectures.                              
       1) [p] Need to understand QEMU codebase to know where to make modifications.
              1) main.c: main() is located here.
                    - Calls 'qemu_init', 'qemu_main_loop', and 'qemu_cleanup'
                    
              2) vl.c: Parses CL arguments and sets up VM based on params like size of ram, hard disk, etc 
                    - 'qemu_init' here parses command line options
                 
              3) All virtual hardware emulated is in hw/ (Can probably leave this alone)
              
       2) [p] Add a machine. See 3.2) above. 
                               
              [x] 1) A new machine source file should go into "hw/arm/" (to fit QEMUs directory structure)
                   -> Defined "CPEA_ARM_GENERIC" variable in "hw/arm/Kconfig" by adding a config section for it.
                   -> Added variable "CONFIG_CPEA_ARM_GENERIC=y" to 'default-configs/devices/arm-softmmu.mak' which tells "make" to use the variable
                   -> Added "arm_ss.add(when: 'CONFIG_CPEA_ARM_GENERIC', if_true: files('cpea.c'))" to 'hw/arm/meson.build' so our Machine file is built.
                   -> init machine in 'hw/arm/cpea.c' using machine API from 'include/hw/boards.h'
                     
              [x] 2) Machine Initializations (Might actually be done with this)
                     SEE 6) for this.
                     1) Default Machine. (Don't need to specify a machine option (-M) )
                     2) ARM Cortex-M4.   (Don't need to specify a CPU option (-cpu) )
                     3) RAM to .5GiB.    (Don't need to specify a memory option (-m) )  
                                            
              [p] 3) Need to write specifications for this machine in "cpea_init()"
                     -> Need memory map for flash, mmio, etc.
                     -> Need to set up NVIC to accompany CPU creation.
       
       3) [p] Executing a FW meant for Cortex-m4
              0) Running commands (for ref)
                 ./qemu-system-arm -display none -s -S -monitor stdio -kernel firmware/test.bin
                 gdb --args ./qemu-system-arm --display none -s -kernel firmware/test.bin
        
              1) "-display none" for no display
              2) "-kernel" is used to load raw binary image
              3) "-s" == "-gdb tcp::1234" for launching a gdb server.
                 Connect with 
                 1) gdb-multiarch
                 2) target remote localhost:1234
              4) "-S" to freeze CPU at startup.
              5) "-d" to enable logging of certain items. '-d help' for list of log items.
              6) "-monitor stdio" Command monitor to analyze QEMU in real time. e.g. 
                                  "info mtree" shows entire address space
                                  "info qom-tree" shows qom tree
                                  "info qtree" more detailed qom tree
              
       4) [p] Understanding QOM, Qdev, SysBus, ARMV7M, ARMCPU, MemoryRegionOps APIs for making our machine.
              Parent Directory: "~/school/thesis/CPEA/qemu/"
              0.1) Where to find ARM class definitions             
                 ARMv7MState: struct that contains ARMCPU and other info for cortex-m CPUs (Since ARMv7M is for  cortex-m)
                              Properties for this device are also commented!
                        @ "~/school/thesis/CPEA/qemu/include/hw/arm/armv7m.h": 53
                             
                 ARMCPUClass: Class struct. This file declares ARMCPU as instance struct, ARMCPUClass as class struct, and ARM_CPU as object name.
                              In short, ARM_CPU is declared as object via OBJECT_DECLARE_TYPE.
                              Provides the 3 standard typedef macros for the object.                                                         
                        @ "~/school/thesis/CPEA/qemu/target/arm/cpu-qom.h"
                 
                 ARMCPU: Primary ARM struct to access ARM CPU. Contains CPUARMState via "env" variable. 
                        @ "~/school/thesis/CPEA/qemu/target/arm/cpu.h": 765
                         
                 CPUARMState (env): Contained in ARMCPU. Holds ARM state such as registers, nvic, etc. 
                        @ "~/school/thesis/CPEA/qemu/target/arm/cpu.h": 229
                 
                 TypeInfo/type_init: Let's QEMU know about the ARM_CPU type to initialize it. Contains init functions:                
                                       - arm_cpu_initfn, arm_cpu_finalizefn, arm_cpu_class_init
                                     which belong to the same file.                                    
                                     Also, arm_cpu_realizefn is set as realize function in arm_cpu_class_init. (Where our CPU check fails for Cortex-m4)                                      
                        @ "~/school/thesis/CPEA/qemu/target/arm/cpu.c": 2343                
              
              0.2) Where to find QOM API
                 TypeInfo: Helps define object types you create
                        @ "~/school/thesis/CPEA/qemu/include/qom/object.h": 413         
              
              
              0.3) Where to find Qdev API
                 DeviceClass: 
                        @ "~/school/thesis/CPEA/qemu/include/hw/qdev-core.h": 97
                 
                 DeviceState:
                        @ "~/school/thesis/CPEA/qemu/include/hw/qdev-core.h": 174 
                        
                 Qdev API: General API with description (e.g. qdev_get_gpio_in, qdev_new, etc)       
                        @ "~/school/thesis/CPEA/qemu/include/hw/qdev-core.h"
                        @ "~/school/thesis/CPEA/qemu/hw/core/qdev.c"
                                 
                                 
              0.4) Where to find Memory API
                 MemoryRegionOps: Allows modification of callback parameters so callbacks are issued in ways you'd want them. 
                        @ "~/school/thesis/CPEA/qemu/include/exec/memory.h": 167
                  
                   
              0.5) Where to find Machine API
                 MachineClass:
                        @ "~/school/thesis/CPEA/qemu/include/hw/boards.h": 158
                         
                 MachineState:
                        @ "~/school/thesis/CPEA/qemu/include/hw/boards.h": 254   
               
              0.6) Where to find SysBus API
                - SysBus con
                System (CPU) Bus Function API: SysBus object creation AND common functions like 'sysbus_init_irq()'
                        @ "~/school/thesis/CPEA/qemu/hw/core/sysbus.c"
                        
                SysBusDevice: Keeps track of registered MMIO via sysbus_init_mmio().
                        @ "~/school/thesis/CPEA/qemu/include/hw/sysbus.h": 54
                                                     
                              
              0.7) Where to find certain object Properties:                       
                 [x] How are some properties made available to devices they don't belong to.
                       For example, 'num-irq' isn't an 'armv7m' property, but it's made available to 'armv7m' through 'armv7m_nvic'
                       Answer: object_property_add_alias() will forward property access from one Type to another. In this case, we forward access to 
                               NVICState from ARMv7MState to use the 'num_irq' Property: "~/school/thesis/CPEA/qemu/hw/arm/armv7m.c": 140
              
                 Property API: API for defining & setting device properties.
                        - Properties are generally stored in members of DeviceStates. (e.g. NVICState contains the property num-irq)
                        - Proprties can usually be found where object Types are created. Will be an array of type "Property" and will be
                          associated with a State Structure (e.g. NVICState)
                        - 
                          
                        @ "~/school/thesis/CPEA/qemu/include/hw/qdev-properties.h"
                 
                 armv7m_nvic_properties: Contains 'num_irq' which is accessed thru armv7m
                        @ "~/school/thesis/CPEA/qemu/hw/intc/armv7m_nvic.c": 2724
                   
                 armv7m_properties: Many of these Properties are forwared to ARM_CPU object
                        @ "~/school/thesis/CPEA/qemu/hw/arm/armv7m.c": 254 
                  
                 arm_cpu_properties: Includes 'core_count'
                        @ "~/school/thesis/CPEA/qemu/target/arm/cpu.c": 2222 
                            
                 cpu_properties: Not any we need to interact with.
                        @ "~/school/thesis/CPEA/qemu/hw/core/cpu.c": 387     
                        
                 arm_gic_properties: Includes 'num-cpu'. 'num_cpu' property is also defined in other files for differenty cortex-a machines.
                        - Note: This property is ONLY defined and used for Cortex-A cpus
                        @ "~/school/thesis/CPEA/qemu/hw/intc/arm_gic_common.c": 349       

             0.8) Where to find certain interrupt APIs: Qdev & SysBus APIs (See Above) contain most of the IRQ code. Some of it is repeated here.  
             
                 ARM GIC: Some implementaton for ARMv7-M Nested Vectored Interrupt Controller. Not the default file.
                        @ "~/school/thesis/CPEA/qemu/hw/intc/arm_gic.c"
                 
                 ARM Nested Vectored Interrupt Controller (NVIC): Default file that is used for arm-softmmu. Not sure when GIC should be used for ARMv7m.
                        @ "~/school/thesis/CPEA/qemu/hw/intc/armv7m_nvic.c"
                        
                 NVICState: Appears to contain list of enabled interrupts through 'VecInfo'
                        @ "~/school/thesis/CPEA/qemu/include/hw/intc/armv7m_nvic.h": 40

                 GICState: Don't see anything too helpful here
                        @ "~/school/thesis/CPEA/qemu/include/hw/intc/arm_gic_common.h": 65
                 
                 Low Level IRQ functions: Qdev uses these. Need them to raise IRQs, lower, etc.
                        @ "~/school/thesis/CPEA/qemu/hw/core/irq.c"
                        @ "~/school/thesis/CPEA/qemu/include/hw/irq.h"
                              
                 IRQState: (e.g. qemu_irq)
                        @ "~/school/thesis/CPEA/qemu/hw/core/irq.c": 32             
                 
                 IRQ Creation: Qdev API     
                        @ "~/school/thesis/CPEA/qemu/include/hw/qdev-core.h"
                        @ "~/school/thesis/CPEA/qemu/hw/core/qdev.c"
               
             0.9) Where to find plugin API to instrument QEMU code execution
                     
                TB/INSN Callbacks: Issue callbacks during translation, instruction, and other events. 
                        @ "~/school/thesis/CPEA/qemu/include/qemu/qemu-plugin.h" 
                        @ "~/school/thesis/CPEA/qemu/plugins/api.c"                  
                                                        
             0.10) Where to find timer and clocking API
             
                QEMU Timers: There are a multitude of different clock types for different applications.
                        @ "~/school/thesis/CPEA/qemu/include/qemu/timer.h"
                        
                CPU Clock: File below contains a note on CPU freq. Not sure if this is how we modify the freq or not.
                        @ "~/school/thesis/CPEA/qemu/include/hw/timer/armv7m_systick.h"        
                        
             0.11) Where to find Chardev API
                
                Front End: API used in the guest rather then a user or external device.
                        @ "~/school/thesis/CPEA/qemu/include/chardev/char-fe.h"
                        @ "~/school/thesis/CPEA/qemu/chardev/char-fe.c"
                
                Back End: API more related to user or external device but still has connections to front end.
                        @ "~/school/thesis/CPEA/qemu/include/chardev/char.h"
                        
                Chardev: Struct for Chardev backend 
                        @ "~/school/thesis/CPEA/qemu/include/chardev/char.h": 59   
                           
                QEMUChrEvent: Enumerations for Char events
                        @ "~/school/thesis/CPEA/qemu/include/chardev/char.h": 20          
                        
                Character Devices: Directory which contains code for all the character devices. (e.g. serial, socket, stdio, etc)       
                        @ "~/school/thesis/CPEA/qemu/chardev/"
                        
             0.12) QEMU Logging           
                           
                                                        
        5) Following code execution to find how it fails
           1) Code fails somewhere in cpu_create()
                 [x] How does cpu_create() make cpu?
                      - Creates a new CPU object generically.
                      - Doesn't provide nvic based on the cpu-type we pass.
                 [x] Find where it fails
                    [x] Re-verify it fails in function. Does not make it past cpu_create()
                    [x] Find the function is fails in within cpu_create
                         - qdev_realize -> many object.c functions -> arm_cpu_realizefn @ "target/arm/cpu.c": 1337 due to lack of NVIC.                          
                    [x] Compare to other peoples' "cortex-m4" creation to see how they avoided this failure  
                         - DONT: They don't use cpu_create because it skips anything with nvic
                         - DO:   I noticed qdev_new() used to encapsulate an entire device e.g. ARMv7m, STM32 SOC, more??
                                 I'm guessing this is where NVIC can be encapsulated. 
                                                
            See 5.1) for tracing execution below.                                                                  
            Following GDB
            cpu_create -> object_new("cortex-m4") -> object_new_with_type -> object_initialize_with_type ->
                break qom/object.c:510 <- Need this to continue past memset
            -> many many many functions -> device_initfn -> object_init_with_type -> 
                break cpu_common_initfn <- to skip to this function
            -> cpu_common_initfn -> arm_cpu_initfn -> arm_cpu_instance_init -> (few more init funcs)
       
            General Breakdown of execution
            qemu_init -> qemu_init_subsystems -> module_call_init(MODULE_INIT_QOM) -> QTAILQ_FOREACH (loop that cycles "register_types" functions) -> cpea_machine_init_register_types -> 
            select_machine -> arm_cpu_class_init (knows I'm using arm binary I guess?) -> cpea_machine_init_class_init -> cpea_machine_init -> qemu_create_machine -> cpea_init -> 
            // this part could change, so placing it down here away from the stuff that won't change
            cpu_create -> object_new -> many functions (setting up object system I'm guessing) -> device_initfc -> object_init_with_type -> cpu_common_initfn -> arm_cpu_initfn ->
            arm_cpu_instance_init -> (few more init funcs) -> DEVICE (qdev_realize arg) -> qdev_realize -> object_property_set_bool (ret by qdev_Realize) -> object_property_set_qobject ->
            many object.c functions (guessing it's trying to determine child objects) -> device_set_realized -> arm_cpu_realizefn -> 
                RETURNS false and causes exit. Ultimately, the error occurs in arm_cpu_realizefn @ "target/arm/cpu.c": 1337 due to lack of NVIC.

/* Integrating CPEA code into QEMU */
5) [p] Integrating CPEA into QEMU
       [p] 1) Get all the source/headers files that need to be compiled alongside QEMU. Place them in "CPEA/qemu/cpea."
              Header files can go into "qemu/include/cpea"             
              [x] - emulatorConfig.c
              [x] - emulatorConfig.h
              [x] - toml.c
              [x] - toml.h
              [p] - Emulate.c (This code may be split across "CPEA/qemu/hw/arm/cpea.c" and "CPEA/qemu/cpea/<filename>")
                              (Added to "CPEA/qemu/cpea") in meantime
                                
       2) [x] Gather all config/setup files and place in root directory ("../CPEA/")
                - emulatorConfig.toml
                - emulatorSetup.py
                   
       3) [p] Provide modifications to QEMU and CPEA source/header files to integrate CPEA into QEMU.           
              (Going in execution order of our Unicorn version)
      
              1) [x] TOML parsing in emulatorConfig.c: "emuConfig()" 
                     -> Placed 'emuConfig()' in cpea.c
                     
              2) [x] Ensure added files from 5.1) are built alongside QEMU. 
                     See "4.2.1)" to see how to add files to a machine. 
                     -> Added "subdir('cpea')" at "qemu/meson.build": 1870 to include "qemu/cpea" directory
                     -> Added Kconfig in "qemu/cpea" to build cpea files
                     -> Added "meson.build" file to "qemu/cpea" which adds cpea source files to "softmmu_ss" and "arm_ss"
                        - Can add files to "softmmu_ss" when they don't include code that belongs to arm_ss. 
                          We add toml.c to softmmu_ss because of this. 
                           
                        - We add files to "arm_ss" when it includes code that is meant to be compiled in the "arm_ss"
                          We include emulatorConfig.c in "arm_ss" because we include "armv7m.h" which is already apart of "arm_ss"
                          In other words, we can't include a source/header file across both source sets.
                        
                        Currently using "softmmu_ss" for toml.c because qemu already defines instructions for how to compile code in 
                        the sourceset. (in "qemu/meson.build") Could make our own sourceset, but would have to define instructions for compiling.
                 
                        1) [p] Would like to add a variable for CPEA to set Y/N that decides if cpea directory is built or not 
                               Made it default to 'Y' in "qemu/cpea" Kconfig file 
                     
                     
                            
              3) [x] MMIO Configurations in emulatorConfig.c: "mmioConfig()"       
                     -> Need to provide replacement for uc_mem_write(): See SOLUTION
                        SOLUTION: We are storing SR values into variables instead of storing to memory. 
                                  This way, we save host memory and can also issue callbacks. See just above.
                                  
                     1) [x] Find replacement for uc_mem_write()
                            - Can use "cpu_physical_memory_rw()":                            
                              "cpu_physical_memory_rw() -> address_space_rw() -> address_space_write() -> flatview_write() \
                               -> flatview_write_continue() -> memory_region_dispatch_write() -> access_with_adjusted_size() \
                               -> etc ... "                           
                                                                                
                            -> To learn more about mem regions & addr spaces: "https://github.com/airbus-seclab/qemu_blog/blob/main/regions.md" 
                               Has additional links to explain them and example code for using/making them. 
      
                            - The function "cpu_physical_memory_rw()" provokes the mmio callback functions, but fails to read back anything via
                              gdb or "cpu_physical_memory_rw(read)." Tried reading from mmio and from flash: Keeps reading back 0x0. 
                              
                            [x] Find why "cpu_physical_memory_rw()" isn't writing/reading emulator memory.
                                To best knowledge, it will only store writes to a region IF that region is backed by host memory.
                                MMIO is not backed by host memory. It only issues callbacks when r/w occur in it's guest memory range.
                                Therefore, MMIO memory region's can't store data for us, we have to store it manually through variables. 
                                1) [s] - Can use RAM region instead. There are variants of RAM regions we could use. (Uses .5GB host memory)
                                         Problem: Are there callbacks? We need callbacks for SR_instances AND fuzzing
                                   
                                2) [x] - Could use MMIO if we stored everything via variables. 
                                         (Lots of work to access correct variable in callbacks. However, not too difficult)
                                         Problem: No post_read for MMIO, only pre_read. (Does this matter?)
                                                               
              4) [p] Get MMIO callbacks working.
                 [p] Add on to callbacks.
                     1) mmioRead(): 
                        - Created armv7m object to read ARM core (R0-R15) at runtime. 
                        - Modified SR Instances to work correctly. 
                        - Other code integrated to support these.
                        1) [] Fuzzing DRs
                        
                     2) mmioWrite():
                        - Nothing really done yet. 
                        1) [] Recording ascii writes in a log for their respective mmio address AND program address.   

                     3) [p] Find the most efficient way to get MMIO data in callbacks for accessed IO addresses.
                           [p] Implemented a hash table which registers IO addresses the user configures.
                              - Good for when a user has a lot of register to configure. Expected to be a lot in some cases, especially
                                if CRs have interrupt functionality tied to them.
                                
                           Problems
                           [p] In MMIO callbacks: Most of the time, we are accessing an IO address that ISNT in the hash table
                                                            
                              1) [ ] (Don't do this) We could also use linear probing, but we'd be searching the hash table for IO addresses that don't exist
                                     so often that it would void the point of using a hash table in the first place.
                              2) [ ] We could use chaining, and quickly search the chain to ensure it's an IO address we can ignore.
                              3) [x] We could implement MemoryRegions ONLY for IO registers the user configures. This way,
                                    IO addresses in callbacks also exist in the hash table and we don't issue callbacks for IO addresses we ignore.
                                      - We'd have to implement a MemoryRegion for each IO address. Can't for the peripheral as a whole because it might contain
                                        IO addresses we are ignoring. Brings us back to the main problem above. 
                                        - This itself presents a small problem. We need the size of each IO address so we can init it correctly. (e.g. byte, word, etc.) 
                                          This can be configured in TOML. Default to 4 bytes. Would be nice to find another fix to avoid more configurations.
                                                
              5) [p] Get Interrupts working: (We are using API already available in QEMU and making no modifications to existing QEMU)
                     - NVIC aligns with ARM General Interrupt Controller (GIC) specification, defined for use with 
                       other ARMv7 profiles and other architectures.
                       
                     - P2IM adds a memory region at 0xffff0000 to stop qemu from thinking it's accessing a non-mapped
                       region when the EXC_RETURN value is placed into the CPU when returning from exceptions.
                       We MAY have to do the same, if we do exceptions the same way.  
                                                                
                     - P2IM interrupt firing: 
                        3 Functions: 1st maintains list of enabled interrupts, 2nd maintains list of disabled interrupts, 3rd fires off interrupts in round-robin fashion. 
                        @ "~/school/thesis/p2im-master/qemu/src/qemu.git/hw/arm/pm_interrupt.c"  
                        
                     0) [p] Learn how QEMU registers IRQs for MMIO and how it fires interrupts for these IRQs.                              
                            [p] General flow of creating IRQs in QEMU based on "Stellaris.c"
                                0) - Each peripheral is it's own Device.
                                   - Some steps could be in different orders depending on where the code is written
                                1) Initialize your IRQ(s) to your main SysBus device (e.g.  'sysbus_init_irq(sbd, &s->irq[n])'   ) 
                                   - Registers the 'out' part of your 'qemu_irq' object. 
                                2) Init the MMIO region for the peripheral (e.g.    'memory_region_init_io(&s->iomem, obj, &stellaris_adc_ops, s, "adc", 0x1000)'    )
                                   - The function example includes registering the callbacks
                                3) Register your MMIO Device MemoryRegion to a SysBus device (e.g.  'sysbus_init_mmio(sbd, &s->iomem)'   )
                                   - SysBus Device will keep a list of all registered MMIO
                                4) Map the SysBus's list of MMIO to to SystemMemory (e.g. sysbus_mmio_map)
                                5) Connect your IRQ 'out' part with it's 'in' part (e.g.    'sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, qdev_get_gpio_in(nvic, 18))'    )    
                                6) Somewhere in those steps, there should be some type of trigger or callback mechanism for triggering the IRQ
                                7) Ultimately, qemu_set_irq(irq, 1) will raise the IRQ. 
                                 
                            [p] Stellaris ADC IRQ flow
                                "(Device Init)"
                                1) sysbus_init_irq(): (qdev_init_gpio_out_named)
                                    - Creates 4 output GPIO lines on SysBus associated with the ADC device's 4 "qemu_irq" arrays.
                                      (Technically, this should be able to raise 4 different IRQs then?)

                                2.1) memory_region_init_io:
                                    - Inits io region for ADC peripheral. Will attach later.
                                     
                                2.2) sysbus_init_mmio():
                                    - Saves ADC's MemoryRegion to the SysBus device (why does sysbus need to know the memory region)
                                
                                3) qdev_init_gpio_in():
                                    - Creates an input GPIO line for their device providing callback for when the line is set.
                                      (This means we'll be attaching another device's output GPIO line to ADC)
                                
                                "(MachineInit)"
                                4) sys_bus_create_varargs(): Wrapper function to connect GPIO lines and map peripheral.
                                   4.1) sysbus_mmio_map(): Attaches the ADC IO addr to system memory.
                                   4.2) sysbus_connect_irq(): Connects 4 of NVIC's (CPU) input GPIO lines to the 4 of ADC's output GPIO lines.                             
                     
                                                                 
                     1) [p] Create the QEMU Interrupt Structure                                                                                        
                            1) [x] Create a Device that's capable of raising IRQs
                                   [x] Device "CPEA_IRQ_DRIVER" created       
                                   [x] Allocate and Init output 'qemu_irq's for "CpeaIRQDriverState"
                                   [x] Create copies of these 'qemu_irq's in each peripheral that has an IRQ enabled
                                   [x] Maintain a list of all enabled IRQn
                                   [x] Connect the 'qemu_irq' of the irq_Driver to the CPU's input IRQn lines
                                       by looping the IRQn list
                            2) [x] Test by firing IRQ
                                   [x] Raise UART IRQ Handler once at specific point in FW. Example in "cpea.c" mmio callback   
                                          
                            3) Need interrupt conditions, but I think we need a peripheral model in place to get some of the conditions.
                               (e.g. FIFO not empty and raises an interrupt)
                                       


                     // Keeping these two in case there is use later                                            
                     x) [ ] Need to monitor writes to QEMU's NVIC or tap into their internal ISER/ICER.
                            - Enabled/Disabled interrupts are exposed through NVICState.
                            [ ] Enabling interrupts in ISER:
                                - Writes to ISER: @ "~/school/thesis/CPEA/qemu/hw/intc/arm_gic.c": 1225
                                [ ] 1) Maintain my own list of enabled interrupts when an interrupt is enabled OR
                                    2) Tap into QEMU's list of enabled interrupts: NVICState->vectors
                                    
                            [ ] Disabling interrupts in ICER:
                                - Writes to ICER: @ "~/school/thesis/CPEA/qemu/hw/intc/arm_gic.c": 1261        
                                [ ] 1) Maintain my own list of disabled interrupts when an interrupt is disabled OR
                                    2) Tap into QEMU's list of disabled interrupts: NVICState->vectors
                                        
                                    
                     x) [ ] Interrupt Firing                              
                            For now: Looks like SCS and NVIC reads are in these two files:
                                     (Confused as to why they split reads between the files)
                                     @ "~/school/thesis/CPEA/qemu/hw/intc/armv7m_nvic.c"
                                     @ "~/school/thesis/CPEA/qemu/hw/intc/arm_gic.c"
                                     @ "~/school/thesis/p2im-master/qemu/src/qemu.git/hw/intc/arm_gic.c"
                                     @ "~/school/thesis/p2im-master/qemu/src/qemu.git/hw/intc/cortexm-nvic.c"
                              

6) [p] Create peripheral models
    0.0) [p] In Python and C, Need to maintain list of acceptable peripheral names
             Instead, might have an interface option for any given peripheral. (serial, socket, etc)
             Should figure out a good way to configure communication to guest devices as we go.
             
    0.1) [p] In C, Keep peripheral IDs that match the peripheral names. Assign to peripherals
    
    1.0) [p] Start with UART or serial 
    1.1) [x] Need chardev API to connect guest frontend to host backend
             - Got front end handlers to work via "qemu_chr_fe_init()" & "qemu_chr_fe_set_handlers()"   
                           
    1.1) [p] Need peripheral model for UART/serial: 
             - RxFIFO fully functional
             - RXFIFO_Full interrupt functional 
                  I think this is complete. Works for 2 completely different UARTs ...
             
             
             
               


/* Making ARM Machine more generic/configurable for any firmware */      
7) [p] Make ARM Cortex-M machine more configurable and automated. 
      Probably should read up on Cortex-m features to be comprehensive.
      Ref:
      Our struct in 0.0)
      See ~/school/thesis/p2im-master/qemu/src/qemu.git/hw/arm/stm32-mcus.c for how they configure machine.
      
      Ideas on setting up machine:
      ~/school/thesis/p2im-master/qemu/src/qemu.git/hw/arm/cortexm-mcu.c
      
      Great list of cortex-m components and hardware:
      https://en.wikipedia.org/wiki/ARM_Cortex-M
      
      0.0) [p] Make struct in "include/hw/arm/cpea.h" to help contain all generic configs. 
               -> Made high level struct "CP_config" encompassing Core and Memory.
               
      0.1) [P] Extend these configs to TOML 
               - Modifiable in TOML
               [] Need to read it out in emulatorConfig
           
      1) [p] Make memory generic and configurable
             - P2IM uses vmstate_register_ram_global() in addition to their mem init.
             - P2IM inits bitband differently w/ cortexm_bitband_init(). Not sure if our "enable bitband" property works in place of this. 
             - P2IM uses read-only RAM as its flash region
                       
             [p] Flash: Have only provided defaults. Need to make configurable in TOML.
                 [p] Base: Set to 0x0. Many other examples set to other addresses.
                           Need to look into alias regions to see exactly how they work.
                                                  
                 [p] Size: Chose a relatively large size. Can probably make this excessively large. 
               
             [p] SRAM: Have only provided defaults: Need to make configurable in TOML.
                 [p] Base: Set for our current MCU
                        
                 [p] Size: Chose a relatively large size. Can probably make this excessively large as well.
                           Note: Don't think this can exceed 32Mb, otherwise might overlap with bitbanding area.
                           
                 [p] SRAM count: Option for multiple SRAMs. Default is 1 SRAM.
                                 By default, can we make 1 large SRAM region that engulfs any other regions that could exist?
                                 Or, do we need the option for multiple regions?
                              
             
      2) [p] Make Cortex-M CPUs more configurable & automated. 
             A lot of these options are QEMU properties for their CPU device.
                                                       
             [x] CPU Model
                 [x] Find way to emulate for ALL Cortex-m machines 
                    - Ultimately, need support for all cortex-m cpus: (armv6m, armv7m, armv8m manuals are online. guessing that encompasses all cortex-m)
                    [x] Find list of CPUs that QEMU supports: "-cpu help"
                        cortex-m0, cortex-m3, cortex-m33, cortex-m4, cortex-m55, cortex-m7 
                    [x] Emulate any cortex-m cpu
                        armv7m object allows execution of cortex-m0, cortex-m3, cortex-m33, cortex-m4 (all verified)
                           (armv6m is upward compatible with armv7m.)   
                        No cortex-m55 example exists in qemu  
                        The properties you'd need to set for any of these devices are available through the armv7m object.
                        Other hardware dependencies are taken care of by QEMU when you specify your CPU model. Not sure to what degree since 
                        it depends on what hardware QEMU supports, but this is true to an extent. 
                        For example, if you choose cortex-m0, your machine won't have an MPU since cortex-m0 doesn't have an MPU.                           
            
             [p] # CPUs
                 - No Co-processors for cortex-m except for m33,m35p cores.
                 - MOST LIKELY going to ignore this for now. The addition and use cases of multiple CPUs
                   can greatly complicate a machine. Most cases in Cortex-m use a single core. 
                  
                 [p] Find out how this could be configurable. 
                     [x] Find if there is a property for this.
                         This is a property of arm_cpu: 'core-count' @ "~/school/thesis/CPEA/qemu/target/arm/cpu.c": 2222
                         However, it isn't needed to add cores. Only see it used in a Cortex-A machine.
                        
                     [p] How to add cpu cores
                         - Can put each CPU in a distinct cluster to have either option:
                             1) configure them differently OR 
                             2) configure them all the same
                            
                           See armsse.c for making the clusters. armsse is just a Device used for making other SSE type machines,
                           but still contains code that could be useful for our machine.
                        
                         - Other cortex-m examples: 2 other examples, but they utilize the armsse code. Appears that armsse is the only example  
                           that really creates multi-core device.
                          
                                                        
             [x] MPU (e.g. y/n): Memory Protection Unit
                 [x] Find where to implement this in QEMU machine creation.
                     Not a property that exists for armv7m, arm_cpu, or cpu objects.
                     Most likely exists depending on the CPU model chosen since it's a flag in ARMCPU.                   
                
             [x] ITM (e.g. y/n): Type of debug module
                 [x] Find where to implement this in QEMU machine creation.
                     Not a property that exists for armv7m, arm_cpu, or cpu objects.               
                
             [x] ETM (e.g. y/n): Type of debug module
                 [x] Find where to implement this in QEMU machine creation.                 
                     Not a property that exists for armv7m, arm_cpu, or cpu objects.
                
             [p] # IRQ: Must be a multiple of 32. (e.g. num_irq = (num_irq + 31) & (~31) ) <- gives next highest multiple of 32.
                        [p] Find out if we can max this out to 480 (armv8m maximum for external intrs.).
                           - Maybe we can max it out for a CPUs max with little issue. (e.g. 32 for cortex-m0, 240 for cortex-m3,  etc) 
                             because even if a FW supports a few IRQ, the FW isn't going to be accessing any IRQ it doesn't support. So, we can provide those
                             extra. (e.g. Only 37 IRQ lines but we provide 480 ... FW is only going to enable/disable 1 of the first 37 and never go out of bounds)
                                                             
                      
             [x] NVIC bits: What's this?
                 I don't see any properties for this. I've seen no one set # of NVIC bits in any of their emulators.
                 [x] Verify whether or not this property exists in QEMU.
                    - Does not exist as a property in NVICState.
            
      3) [p] Other Board configs to possibly make more automated.                            
             [p] SysStick timer: Currently have 1 that's non-configurable, with non-configurable freq.
                 [p] Does this need to be configurable?
                     Systick is optional for m0,m1,m23. Required for m3,m4,m7,m33,m35p
                     I don't think it hurts to enable for all.
                        
             [x] bitband: expose bitbanded IO. Is a property for armv7m obj.
                 Bitband Properties: P2IM seemed to use these at one point. Keeping as reference.
                     @ "~/school/thesis/CPEA/qemu/hw/arm/armv7m.c":338
                 - 2 Bitband regions occupy the lowest 1MB of SRAM and peripheral memory regions.
                     @ [0x20000000, 0x2010000) & [0x40000000, 0x40100000)  
                 - Also exists 2 32MB alias regions to access bitband regions
                     @ [0x22000000, 0x24000000) & [0x42000000, 0x44000000)
                   
                 [x] What cortex-m cpus have bitbanding
                     optional for m3,m4,m7 AND feature can be added to m0/m0+ 
                     
                 [x] Should we make configurable?: YES       
                     Yes, because we don't want to always include bitband for cpus that DONT have a bitband.
                     Otherwise, accesses to alias region will attempt to access bitband region.
                     
             [p] VTOR: 
                 [x] What CPUs have VTOR
                     - All cortex-m can have a VTOR. Appears optional for some.
                       This includes armv6m, armv7m, and armvm8
                       In armv8m, VTOR holds the vector table address for the selected security state.
          
                 [x] Does a property exist for VTOR? 
                     No, This is because the VTOR is accessible through cpu->env.v7m.vecbase which is accessed upon reads/writes to 
                     System Control Block. It's not configurable by user as firmware is responsible to read/write to it.
                     
                 [p] sVTOR/nsVTOR: init_svtor is a property, init_nsvtor is property in upstream QEMU.
                     - sVTOR exists for armv8m and the property exists in hhe armv7m object.
                     - nsVTOR patch: https://patchwork.kernel.org/project/qemu-devel/patch/20210520152840.24453-10-peter.maydell@linaro.org/
                     - cpu->env.v7m.vecbase contains attributes from IDAU even. 
                     [x] Does sVTOR have correlation to IDAU?
                         Yes, IDAU (Implementation Defined Attribution Unit) can make an address secure, non-secure, or non-secure callable.
                         Either of this attributions can affect VTOR.
                         Seems like one would need to include IDAU if they were to use sVTOR. See idau below for more info.                    
    
             [p] idau: IDAU interface
                 - This is also a configurable property of armv7m devices
                 [p] Find out if this needs to be configurable.
                     - Part of armv8m TrustZone. Tells if mem addr is Secure, Non-secure Callable, or Non-secure.
                     - Don't think we need to worry too much about this for most cases.
                       More complicated than other configs, looks like it requires additional functions from examples.
                     - Apparantly, there is an IDAUInterface object which probably helps define idau and how it works.
                 [x] How is IDAU used in QEMU?
                     - One example exists in armsse.c, where it seems like idau can be slightly different from machine to machine.    
                       (They write an IDAU 'implementation specific' callback for ARMSSE systems)  
                       It's defined as a property that can be linked to your device. 
                       
             [x] FPU instructions: Always set true for armv7m
                 - Optional extension in armv7m, so we would want to enable this always as it doesn't hurt anything.
                 -> Set true for the "armv7m" device I created according to qtree
                 
             [x] DSP instructions: Always set true for armv7m
                 - Optional extension in armv7m, so we would want to enable this always as it doesn't hurt anything
                 -> Set true for the "armv7m" device I created according to qtree
                              
      3) [x] Make MMIO configurable 
             [x] Can add peripherals, edit number of DR/SRs, apply addresses registers, and 
                 set/unset SR bits at particular addresses to pass SR checks.    


Scratch Area
[] Follow in order, the steps involved with stellaris.c UART creation and how a user might interact with it.
   These are steps for setting up a serial port to interact with UART.
   
    NOTE: Can use "find -iname <file>" to search for files mentioned.
    
    Stellaris uart initialization
    0) "pl011.c" is where uart is emulated.
    1) "stellaris.c": 1377 Call "pl011_luminary_create()" device creation function passing "Chardev *serial_hd(i)"
    2) "pl011.h": 80 Call "qdev_new()" to create the uart device and go through it's device init function.
                     The device init function in "pl011.c": 369 initializes mmio region, clock, and uart registers
    3) "pl011.h": 82 Call "qdev_prop_set_chr()" to set PL011State's "chardev" property with "Chardev *serial_hd(i)"
                     Confusing part is that PL011State only has a variable "CharBackend chr" which is not type "Chardev *"
                     "pl011.c": 364 shows "CharBackend chr"'s property definition. 
    3.1) "sysemu.h": 72 "Chardev *serial_hd(int i)" is a function that returns the Chardev for serial port i.
                         Also likely sets up the connect to the serial port.
                         Keep in mind, Chardev connects to a backend that a user/external device would connect to.                                                  
    3.2) NOW, that PL011State->CharBackend has its Chardev, will likely be used in "pl011.c" during its emulation.                 
    4) "pl011.h": 84-85 Places uart hwaddr in SysBus and then connects uart's output IRQ to CPU's input IRQ.
    
    x) UART initialization in "stellaris.c" is complete. UART was connected to a serial port. See "pl011.c" for its use.
       Going to go over the uart device initialization now.
    
    Character Device Setup for uart
    5) "pl011.c": 395 Call "qemu_chr_fe_set_handlers()" to set the front end char handlers. (sets callbacks)
                      "pl011_can_receive" returns amount of char data frontend may receive. Not sure when it's called.
                      "pl011_receive" callback to receive data from external char device. Places received data in a FIFO.
                      "pl011_event" event callback issued when a particular "QEMUChrEvent" occurs.
                       
    Character Device Emulation (Not in any particular order because any of this can happen at any time during emulation)
    6) "pl011.c": 107 Call "qemu_chr_fe_accept_input(&s->chr)" during uart DR read to notify the front end is ready to Rx data.
                      I'd like to see the source code for this function to see what it's doing. The API explanation doesn't tell me.
                      
    7) "pl011.c": 207 Call "qemu_chr_fe_write_all()" during uart DR write to write data from frontend to backend. Will block if the 
                      backend cannot consume all the data. Function is thread-safe. (block == Blocks entire thread)
    8) "pl011_receive": In 5), this callback "fd_read" is issued when external device writes (I think). The callback places data into a FIFO that is used
                        for uart DR reads/writes and interrupts. 

    

/* Getting executable binary from a proper ELF */  
arm-none-eabi-objcopy -O binary <elf> <bin>

                                                       
/* Compiling the Emulators */
gcc EmulateUart.c emulatorConfig.c toml.c tester.c -lunicorn -lpthread

/* Generating ELF file: Compiling the Source Code to emulate */
arm-none-eabi-gcc -specs=nosys.specs SimpleUart.c -o SimpleUart.elf
or
arm-none-eabi-gcc -specs=nosys.specs PollingUart.c -o PollingUart.elf

/* Compiling and Making Unicorn */        
Command to install and compile Unicorn
./make.sh (assumes config file only makes for ARM)
sudo ./make.sh install

/* Setting Unicorn Library path for GCC */
1.) Undefined References to pthread functions
    - place lpthread after lunicorn
2.) Can't find libunicorn.so.1 when running executable
    - Run 'ldd a.out' to see what libraries are found and where
    - Add the path of libunicorn.so.1 to GCC library path @ /etc/ld.so.conf.d/x86_64-linux-gnu.conf
    - run sudo ldconfig to update library cache
  
/* Getting TOML to work with CPEA */
C Parser
	1) Include toml.h and toml.c files.
Python3 TOML Parser
	tomlkit
	1) pip install tomlkit 

/* Getting ELF Parsing to work with CPEA */
Python3 ELF Parser
	pyelftools
	1) pip install pyelftool  
  
  
/* Deprecated methods for getting Raw Binary to execute */ 

/* Producing Hex String from assembly */   
Assembly to Hex String
rasm2 -a arm -C -f arm.asm

/* Manually producing binaries to emulate */
Compiling C code to 32-bit ARM
To Produce Assembly:
	arm-none-eabi-gcc -marm -S (--specs=nosys.specs) SimplePollUart.c -o SimplePollUart.s
    		  	               (optional, may want to try)
To Assemble:
	arm-none-eabi-as -o SimplePollUart.o SimplePollUart.s

To Compile,assemble,link
	arm-none-eabi-gcc -marm SimplePoll_uart.c

To Print Opcode
   - Radare2 to print out opcode. Add '00' to end of file to add terminator.
      - Go to entry point with command
         'p8 [N]' to print hexpair list for N bytes and remember to add '00' string terminator
         
To Convert to Raw Binary
    - 'xxd -r -p input.opcode output.bin' to get raw binary
	  - Read this into Unicorn and store in char array. :)


