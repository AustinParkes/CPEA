/* Running qemu full system emulation */
./qemu-system-arm -display none
gdb --args ./qemu-system-arm --display none

/* Other Project Names */
CPEFF - Configurable Peripheral Emulator and Fuzzing Framework
CPEF - Configurable Peripheral Emulator and Fuzzer

/* Emulating Firmware */
Write a Unicorn program that executes a firmware
   Memory Mapping
      - ARM defines a standardized address space of 4GB
         - Code area starts at 0x00000000 and aliases 0x08000000 (routine at 0x080016DC and be accessed from 0x000016DC)
            - Includes SP, Reset, Vector Table
            -> Refer to Ghidra/Radare2 to get address ranges for now. May be able to automate this later
         - MMIO ranges 0x40000000 - 0x5fffffff 
         - Stack / Heap (0x200xx000 - 0x20000000)
         	- Resides in SRAM where .data (VMA) and .bss are
         - 	
         	
   MMIO Callbacks 
      - // TODO: Document how this is done. 
   
   User Configurations
      - Think about what needs to be configured by the user specifically to configure their emulator
      Peripherals
         -> User gives
            1) Give address of a peripheral (e.g. USART1)
            2) Give the register address a particular bit functionality (e.g. USART1->CR1 mapped to USART1 enable)
            3) Give the specific bit in that register that triggers that functionality
            
            - Registers can be 8 bit, 32 bit, other? (check for 16 bit registers ... just keep reading on other periphs)
               - How do we emulate for 8 bit registers? (How does fw interact with 8 bit)
                  - I want to know if we can keep 32 bit or if we need to have two different modes for 8 bit and 32 bit
                     (May very well need an 8 bit mode.)
                     - How do 32 bit UARTs compare to each other and how do 8 bit  UARTS compare to each other



/* Firmware Testing */                     
Testing Emulator with Real Firmware
   Researching Firmware to Test
      - FW details
         - Should allow ELF or Raw Binary
         - Should be for ARM Cortex-M devices. (for now)        
      - Where to find FW?
	     - Find FW that other papers tested 
	        -> Find all the papers that Austin sent last summer                  
		 - How did other papers find FW?
		    - Unit Tests
		       - They found examples from OS libraries. 
		    - Real Firmware
		       - Lots of Github source code that was compiled with some IDE
		       - binaries are available as ARM ELF files. No, raw binaries.   
		       
		          		          
   Testing Peripherals
      - Which peripherals to test?
         - Most popular?, P2IM mentions: SPI, USART, I2C, GPIO, ADC, DAC, TIMER, PWM
   		 -> Any, just want to see if the SR values pass.
   		     
   Testing Binaries
      - What form does binary need to be in? ELF or Raw Binary?
         - P2IM uses ELF files         
      -> Want to be able to support ELF or raw binaries. (ELF first)
         ELF Files
            -> Could execute ELF by just providing it
               -> Could gather ELF info and execute from entry point and auto generate memory map with Python script.
               
            -> Can additionally allow user to manually execute points of interest like with Raw binary option below. 
               
         Raw Binary 
            -> Will require manual intervention from user to provide start/stop points, processor state,
              memory map, etc. 


/* Todo list */
[x] - Complete
[p] - In Progress
[s] - Skipping
[ ] - Not Started

   TODO     
      Integrating into QEMU
      1) [x] Save backup of our current code and document what it does and doesn't do.
      2) [x] Make new branch for qemu-integration and get qemu code base into it.
                - No submodule, pulling. Instead, downloaded and copied it into repo.
      3) [x] Move files into repo that won't be compiled with qemu source
                - Python scripts, firmware, etc.            
      4) [x] Figure out how to build QEMU.
      SEE "Building QEMU on Ubuntu 20.04" BELOW FOR MORE.
      
      General Category
      1) [p] Init SP/FP given ELF file (ARM ELF for Linux and barebones MCU) and Raw Binary
                - Need to test with an actual extracted Raw Binary.
      2) [x] Map in entire memory region for Cortex-M devices (so it doesn't need to be automated from ELF. Reduces complexity)
      3) [x] Read multiple data sections from ELF and store them all. 
      4) [ ] To avoid mapping 4GB by default: For memory mapping, could try and map certain memory sections during execution.
             - Can map memory for each MMIO we do configure.
             - Can map memory for each unmapped MMIO we don't configure.
             - Can map memory for the start addr and size of our FW image.
             - Can map other accessed unmapped regions on the fly. (unkown scenarios with this solution.)
      5) [ ] Need to give user option to start/stop ELFs/Raw Binaries from anywhere, instead of the default reset handler.
      6) [x] Need to let user set SR bits at certain addresses that SRs are accessed.
             (SR ideal bit values can change over course of FW execution.)
             Can implement this as callback for 1) Every instruction execution 2) Every mapped MMIO access
             Bug Checks             
      7) [ ] Allow user to set starting address of FW. Currently assumed to start at 0, but could start at 0x0800 0000 for example.
             FW will reference data according to where it's located virtually, so need to account for this.  
             See map_memory() and flash_init().
                                                                  
      Interrupts                                                                  
      1) [P] Find how to detect which interrupts are enabled in FW via NVIC or vector table.
                Can issue a callback for anytime ISER/ICER are accessed. 
                Need to emulate these registers to some degree and keep a list of enabled interrupts
                based on how ISER and ICER are written to. P2IM used some NVIC_PENDING register to help fire? look into it
                                                                     
      2) [P] Create an interrupt firing strategy for the interrupts that are enabled.
                Want to figure out why RTC isn't being enabled.
                Or, why we get stuck in an infinite loop.

      Debugging
      1) [ ] Find a way for user to step through code line by line. (GDB stubs an option?)
             Want something to work for ELFs, Raw Binaries, etc.
      
      Automation
      1) [x] Implement "Generic" peripherals with generic flags
      2) [x] Add option for user to change polarity of a SR bit so they can set default
             value to '0' or '1' (observed that status bit can be checked to be 0 or 1).
             Can add a "Value =" key, for which '0' and '1' are the only values. 
      3) [x] Add option for user to specify the SR access address that they want the value to take effect at.
             - Automate from python: Add to inline table
             - Parse in C: Need to set SR values in callback when address is accessed.
             Could infer acceptable values for SR bits for polling scenarios, but there may be other scenarios where instead of polling (hanging),
             FW could instead crash upon an incorrect SR bit. Therefore, will have user manually specify bits at certain addresses for this reason. 
      4) [ ] Add a count for number of generic flags the user may want to set for any given peripheral.        



      Misc
      1) [x] Find if uc_mem_map() allocates space in host memory. Use valgrind to check.      
                              
      Bugs (or potential problems)
      1) [x] Memory Leak somewhere related to TOML.
      2) [x] Stack Smashing error in mmioConfig().
      3) [x] SR "bit" value in config isn't confined to SR limits. Can be any number.
      4) [x] Init registers in MMIO struct to 0, perhaps other MMIO members as well. 
      5) [x] Get min/max addr for each module in parseKeys(). Need it for determining which peripheral we've accessed. 
      6) [x] memory leak related to the root toml table                    
      
   Queries
      1) [HANDLED] Does the memory map have to be specific to MCU? Or can we make it expand the range specified for ARM Cortex-M MCUs. 
         See [mem_map] in emulatorConfig.toml as example.
         Used ARMv7 Arch reference manual.  
      2) [HANDLED] How will we handle Raw binaries and stripped ELF files? 
         Stripped ELF files should still have LOAD program headers, so they'd be the same as 
         non-stripped ELFs. Raw binaries might be the same as the output we get from extracting
         LOAD sections from the ELF... so might be finished on that front. Just need to double check.                    
      3) [CURIOUS] In what context are dynamically linked ELFs used? Currently, we only create binary from statically linked.
                   Would we need to create binary from dynamically linked?

/* Building QEMU on Ubuntu 20.04 */
1) [x] Installations to build 
            sudo apt-get install libnfs-dev libiscsi-dev from QEMU's build page
            sudo apt-get install libglib2.0-dev
            sudo apt-get install libpixman-1-dev

2) [x] Clone QEMU. Get Submodule Code. Remove repositories for QEMU and submodules, but keep their relevant code.
       1) [x] Remove qemu/ as repo. (rm -r .git)
       2) [x] Remove submodules from qemu/ (rm .gitmodules AND rm .git for each submodule)
                 meson/, capstone/, dtc/, slirp/, roms/., tests/fp/. 
                 
3) [p] Building
       1) [x] Make 'build/' directory and enter it.  
       2) [x] Run './configure --enable-debug --target-list=arm-softmmu' to only build files for ARM.
       3) [p] Run 'make.' (Very Lengthy Process to build the binaries. Would like to lessen the time by building only what we need.)
              // TODO: Can (probably) delete files we don't need care to compile.
       4) [x] Need to figure out how to include my own files into the build.
       5) SEE 4.2) for adding own files. 

4) [p] Executing 'qemu-arm-softmmu'                        
       1) [p] Need to understand QEMU codebase to know where to make modifications.
              1) main.c: main() is located here.
                    - Calls 'qemu_init', 'qemu_main_loop', and 'qemu_cleanup'
                    
              2) vl.c: Parses CL arguments and sets up VM based on params like size of ram, hard disk, etc 
                    - 'qemu_init' here parses command line options
                 
              3) All virtual hardware emulated is in hw/ (Can probably leave this alone)
              
       2) [p] Add a machine. See 3.2) above.                   
              1) A new machine source file should go into "hw/arm/" (to fit QEMUs directory structure)
                   -> Defined "CPEA_GENERIC" variable in "hw/arm/Kconfig" by adding a config section for it.
                   -> Added variable "CONFIG_CPEA_GENERIC=y" to 'default-configs/devices/arm-softmmu.mak' 
                   -> Added "arm_ss.add(when: 'CONFIG_CPEA_GENERIC', if_true: files('cpea.c'))" to 'hw/arm/meson.build' so our Machine file is built.
                   -> init machine in 'hw/arm/cpea.c' using machine API from 'include/hw/boards.h'
                     
              2) Machine Initializations
                   1) Default Machine. (Don't need to specify a machine option (-M) )
                   2) ARM Cortex-M4.   (Don't need to specify a CPU option (-cpu) )
                   3) RAM to .5GiB.    (Don't need to specify a memory option (-m) )  
                     
                        
              3) Need to write specifications for this machine in "cpea_init()"
                   -> Need memory map for flash, mmio, etc.
                   -> Need to set up NVIC to accompany CPU creation.
              
              
       3) [p] Execute a FW meant for Cortex-m4
              0) Running commands (for ref)
                 ./qemu-system-arm -display none -s -S -kernel firmware/test.bin
                 gdb --args ./qemu-system-arm --display none -s -kernel firmware/test.bin
        
              1) "-display none" for no display
              2) "-kernel" is used to load raw binary image
              3) "-s" == "-gdb tcp::1234" for launching a gdb server.
                 Connect with 
                 1) gdb-multiarch
                 2) target remote localhost:1234
              4) "-S" to freeze CPU at startup.
              5) "-d" to enable logging of certain items. '-d help' for list of log items.
              
       4) [p] Understanding QOM, Qdev, and SysBus to make our hardware
              0) Where to find ARM class definitions
                 ARMCPUClass: Class struct. This file declares ARMCPU as instance struct, ARMCPUClass as class struct, and ARM_CPU as object name.
                              In short, ARM_CPU is declared as object via OBJECT_DECLARE_TYPE.
                              Provides the 3 standard typedef macros for the object.                                                         
                         @ "target/arm/cpu-qom.h"
                 
                 ARMCPU: Primary ARM struct to access ARM CPU. Contains CPUARMState via "env" variable. 
                         @ "target/arm/cpu.h": 765
                         
                 CPUARMState: Contained in ARMCPU. Holds ARM state such as registers, nvic, etc. 
                         @ "target/arm/cpu.h": 229
                 
                 TypeInfo/type_init: Let's QEMU know about the ARM_CPU type to initialize it. Contains init functions:                
                                       - arm_cpu_initfn, arm_cpu_finalizefn, arm_cpu_class_init
                                     which belong to the same file.                                    
                                     Also, arm_cpu_realizefn is set as realize function in arm_cpu_class_init. (Where our CPU check fails for Cortex-m4)                                      
                         @ "target/arm/cpu.c": 2343                
                                                        
              1) Code fails somewhere in cpu_create()
                 [x] How does cpu_create() make cpu?
                      - Creates a new CPU object generically.
                      - Doesn't provide nvic based on the cpu-type we pass.
                 [] Find where it fails
                    [x] Re-verify it fails in function. Does not make it past cpu_create()
                    [x] Find the function is fails in within cpu_create
                         - qdev_realize -> many object.c functions -> arm_cpu_realizefn @ "target/arm/cpu.c": 1337 due to lack of NVIC.                          
                    [x] Compare to other peoples' "cortex-m4" creation to see how they avoided this failure  
                         - DONT: They don't use cpu_create because it skips anything with nvic
                         - DO:   I noticed qdev_new() used to encapsulate an entire device e.g. ARMv7m, STM32 SOC, more??
                                 I'm guessing this is where NVIC can be encapsulated. 
                                                
                                                                   
4) Following GDB
    cpu_create -> object_new("cortex-m4") -> object_new_with_type -> object_initialize_with_type ->
       break qom/object.c:510 <- Need this to continue past memset
    -> many many many functions -> device_initfn -> object_init_with_type -> 
       break cpu_common_initfn <- to skip to this function
    cpu_common_initfn -> arm_cpu_initfn -> arm_cpu_instance_init -> (few more init funcs)
       
    General Breakdown of execution
    qemu_init -> qemu_init_subsystems -> module_call_init(MODULE_INIT_QOM) -> QTAILQ_FOREACH (loop that cycles "register_types" functions) -> cpea_machine_init_register_types -> 
    select_machine -> arm_cpu_class_init (knows I'm using arm binary I guess?) -> cpea_machine_init_class_init -> cpea_machine_init -> qemu_create_machine -> cpea_init -> 
    // this part could change, so placing it down here away from the stuff that won't change
    cpu_create -> object_new -> many functions (setting up object system I'm guessing) -> device_initfc -> object_init_with_type -> cpu_common_initfn -> arm_cpu_initfn ->
    arm_cpu_instance_init -> (few more init funcs) -> DEVICE (qdev_realize arg) -> qdev_realize -> object_property_set_bool (ret by qdev_Realize) -> object_property_set_qobject ->
    many object.c functions (guessing it's trying to determine child objects) -> device_set_realized -> arm_cpu_realizefn -> 
       RETURNS false and causes exit. Ultimately, the error occurs in arm_cpu_realizefn @ "target/arm/cpu.c": 1337 due to lack of NVIC.


5) [ ] Integrating CPEA into QEMU
       [p] 1) Get all the source/headers files that need to be compiled alongside QEMU. Place them in "CPEA/qemu/cpea."
              Header files can go into "qemu/include/cpea"             
              [x] - emulatorConfig.c
              [x] - emulatorConfig.h
              [ ] - toml.c
              [ ] - toml.h
              [p] - Emulate.c (This code may be split across "CPEA/qemu/hw/arm/cpea.c" and "CPEA/qemu/cpea/<filename>")
                              (Added to "CPEA/qemu/cpea") in meantime
                                
       [x] 2) Gather all config/setup files and place in root directory ("../CPEA/")
                - emulatorConfig.toml
                - emulatorSetup.py
                
       [ ] 3) Provide modifications to QEMU and CPEA source/header files to integrate CPEA into QEMU.           
              (Going in execution order of our Unicorn version)
              [ ] TOML parsing          
                

/* Getting executable binary from a proper ELF */  
arm-none-eabi-objcopy -O binary <elf> <bin>

                                                       
/* Compiling the Emulators */
// TODO: Eventually want to make my added files apart of the unicorn library
gcc EmulateUart.c emulatorConfig.c toml.c tester.c -lunicorn -lpthread


/* Generating ELF file: Compiling the Source Code to emulate */
arm-none-eabi-gcc -specs=nosys.specs SimpleUart.c -o SimpleUart.elf
or
arm-none-eabi-gcc -specs=nosys.specs PollingUart.c -o PollingUart.elf

/* Compiling and Making Unicorn */        
Command to install and compile Unicorn
./make.sh (assumes config file only makes for ARM)
sudo ./make.sh install

/* Setting Unicorn Library path for GCC */
1.) Undefined References to pthread functions
    - place lpthread after lunicorn
2.) Can't find libunicorn.so.1 when running executable
    - Run 'ldd a.out' to see what libraries are found and where
    - Add the path of libunicorn.so.1 to GCC library path @ /etc/ld.so.conf.d/x86_64-linux-gnu.conf
    - run sudo ldconfig to update library cache
  
/* Getting TOML to work with CPEA */
C Parser
	1) Include toml.h and toml.c files.
Python3 TOML Parser
	tomlkit
	1) pip install tomlkit 

/* Getting ELF Parsing to work with CPEA */
Python3 ELF Parser
	pyelftools
	1) pip install pyelftool  
  
  
/* Deprecated methods for getting Raw Binary to execute */ 

/* Producing Hex String from assembly */   
Assembly to Hex String
rasm2 -a arm -C -f arm.asm

/* Manually producing binaries to emulate */
Compiling C code to 32-bit ARM
To Produce Assembly:
	arm-none-eabi-gcc -marm -S (--specs=nosys.specs) SimplePollUart.c -o SimplePollUart.s
    		  	               (optional, may want to try)
To Assemble:
	arm-none-eabi-as -o SimplePollUart.o SimplePollUart.s

To Compile,assemble,link
	arm-none-eabi-gcc -marm SimplePoll_uart.c

To Print Opcode
   - Radare2 to print out opcode. Add '00' to end of file to add terminator.
      - Go to entry point with command
         'p8 [N]' to print hexpair list for N bytes and remember to add '00' string terminator
         
To Convert to Raw Binary
    - 'xxd -r -p input.opcode output.bin' to get raw binary
	  - Read this into Unicorn and store in char array. :)
	 

