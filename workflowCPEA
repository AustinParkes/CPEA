/* Emulating Firmware */
Write a Unicorn program that executes a firmware
   Memory Mapping
      - ARM defines a standardized address space of 4GB
         - Code area starts at 0x00000000 and aliases 0x08000000 (routine at 0x080016DC and be accessed from 0x000016DC)
            - Includes SP, Reset, Vector Table
            -> Refer to Ghidra/Radare2 to get address ranges for now. May be able to automate this later
         - MMIO ranges 0x40000000 - 0x5fffffff 
         - Stack / Heap (0x200xx000 - 0x20000000)
         	- Resides in SRAM where .data (VMA) and .bss are
         - 	
         	
   MMIO Callbacks 
      - // TODO: Document how this is done. 
   
   User Configurations
      - Think about what needs to be configured by the user specifically to configure their emulator
      Peripherals
         -> User gives
            1) Give address of a peripheral (e.g. USART1)
            2) Give the register address a particular bit functionality (e.g. USART1->CR1 mapped to USART1 enable)
            3) Give the specific bit in that register that triggers that functionality
            
            - Registers can be 8 bit, 32 bit, other? (check for 16 bit registers ... just keep reading on other periphs)
               - How do we emulate for 8 bit registers? (How does fw interact with 8 bit)
                  - I want to know if we can keep 32 bit or if we need to have two different modes for 8 bit and 32 bit
                     (May very well need an 8 bit mode.)
                     - How do 32 bit UARTs compare to each other and how do 8 bit  UARTS compare to each other



/* Firmware Testing */                     
Testing Emulator with Real Firmware
   Researching Firmware to Test
      - FW details
         - Should allow ELF or Raw Binary
         - Should be for ARM Cortex-M devices. (for now)        
      - Where to find FW?
	     - Find FW that other papers tested 
	        -> Find all the papers that Austin sent last summer                  
		 - How did other papers find FW?
		    - Unit Tests
		       - They found examples from OS libraries. 
		    - Real Firmware
		       - Lots of Github source code that was compiled with some IDE
		       - binaries are available as ARM ELF files. No, raw binaries.   
		       
		          		          
   Testing Peripherals
      - Which peripherals to test?
         - Most popular?, P2IM mentions: SPI, USART, I2C, GPIO, ADC, DAC, TIMER, PWM
   		 -> Any, just want to see if the SR values pass.
   		     
   Testing Binaries
      - What form does binary need to be in? ELF or Raw Binary?
         - P2IM uses ELF files         
      -> Want to be able to support ELF or raw binaries. (ELF first)
         ELF Files
            -> Could execute ELF by just providing it
               -> Could gather ELF info and execute from entry point and auto generate memory map with Python script.
               
            -> Can additionally allow user to manually execute points of interest like with Raw binary option below. 
               
         Raw Binary 
            -> Will require manual intervention from user to provide start/stop points, processor state,
              memory map, etc. 


/* Todo list */
[x] - Complete
[p] - In Progress
[ ] - Not Started
   TODO     
      Integrating into QEMU
      1) [x] Save backup of our current code and document what it does and doesn't do.
      2) [x] Make new branch for qemu-integration and get qemu code base into it.
                - No submodule, pulling. Instead, downloaded and copied it into repo.
      3) [x] Move files into repo that won't be compiled with qemu source
                - Python scripts, firmware, etc.            
      4) [ ] Figure out how to build QEMU.
      
      General Category
      1) [p] Init SP/FP given ELF file (ARM ELF for Linux and barebones MCU) and Raw Binary
                - Need to test with an actual extracted Raw Binary.
      2) [x] Map in entire memory region for Cortex-M devices (so it doesn't need to be automated from ELF. Reduces complexity)
      3) [x] Read multiple data sections from ELF and store them all. 
      4) [ ] To avoid mapping 4GB by default: For memory mapping, could try and map certain memory sections during execution.
             - Can map memory for each MMIO we do configure.
             - Can map memory for each unmapped MMIO we don't configure.
             - Can map memory for the start addr and size of our FW image.
             - Can map other accessed unmapped regions on the fly. (unkown scenarios with this solution.)
      5) [ ] Need to give user option to start/stop ELFs/Raw Binaries from anywhere, instead of the default reset handler.
      6) [x] Need to let user set SR bits at certain addresses that SRs are accessed.
             (SR ideal bit values can change over course of FW execution.)
             Can implement this as callback for 1) Every instruction execution 2) Every mapped MMIO access
             Bug Checks             
      7) [ ] Allow user to set starting address of FW. Currently assumed to start at 0, but could start at 0x0800 0000 for example.
             FW will reference data according to where it's located virtually, so need to account for this.  
             See map_memory() and flash_init().
                                                                  
      Interrupts                                                                  
      1) [P] Find how to detect which interrupts are enabled in FW via NVIC or vector table.
                Can issue a callback for anytime ISER/ICER are accessed. 
                Need to emulate these registers to some degree and keep a list of enabled interrupts
                based on how ISER and ICER are written to. P2IM used some NVIC_PENDING register to help fire? look into it
                                                                     
      2) [P] Create an interrupt firing strategy for the interrupts that are enabled.
                Want to figure out why RTC isn't being enabled.
                Or, why we get stuck in an infinite loop.

      Debugging
      1) [ ] Find a way for user to step through code line by line. (GDB stubs an option?)
             Want something to work for ELFs, Raw Binaries, etc.
      
      Automation
      1) [x] Implement "Generic" peripherals with generic flags
      2) [x] Add option for user to change polarity of a SR bit so they can set default
             value to '0' or '1' (observed that status bit can be checked to be 0 or 1).
             Can add a "Value =" key, for which '0' and '1' are the only values. 
      3) [x] Add option for user to specify the SR access address that they want the value to take effect at.
             - Automate from python: Add to inline table
             - Parse in C: Need to set SR values in callback when address is accessed.
             Could infer acceptable values for SR bits for polling scenarios, but there may be other scenarios where instead of polling (hanging),
             FW could instead crash upon an incorrect SR bit. Therefore, will have user manually specify bits at certain addresses for this reason. 
      4) [ ] Add a count for number of generic flags the user may want to set for any given peripheral.        



      Misc
      1) [x] Find if uc_mem_map() allocates space in host memory. Use valgrind to check.      
                              
      Bugs (or potential problems)
      1) [x] Memory Leak somewhere related to TOML.
      2) [x] Stack Smashing error in mmioConfig().
      3) [x] SR "bit" value in config isn't confined to SR limits. Can be any number.
      4) [x] Init registers in MMIO struct to 0, perhaps other MMIO members as well. 
      5) [x] Get min/max addr for each module in parseKeys(). Need it for determining which peripheral we've accessed. 
      6) [x] memory leak related to the root toml table                    
      
   Queries
      1) [HANDLED] Does the memory map have to be specific to MCU? Or can we make it expand the range specified for ARM Cortex-M MCUs. 
         See [mem_map] in emulatorConfig.toml as example.
         Used ARMv7 Arch reference manual.  
      2) [HANDLED] How will we handle Raw binaries and stripped ELF files? 
         Stripped ELF files should still have LOAD program headers, so they'd be the same as 
         non-stripped ELFs. Raw binaries might be the same as the output we get from extracting
         LOAD sections from the ELF... so might be finished on that front. Just need to double check. 
      3) [IMPORTANT] Investigate. Does the Console FW read/write registers like CONTROL, NVIC regs, etc. (Does it fail upon access?)  
                     Good to know, because if unicorn doesn't fail to execute them, then we likely have access to them in some way.  
                     MRS/MSR instructions will likely be used for CONTROL reg but not NVIC. 
                     NVIC is located within the System Control Space (SCS).                    
      4) [IMPORTANT] Consider scenario where vector table is offset. Will we need the VTOR to locate it and 
                     corresponding interrupt handlers. (User would configure VTOR if this happens)   
                     May use VTOR anyway to help match interrupt numbers to the handler addresses.                                                 
      5) [CURIOUS] Look for Software Triggered Interrupt Register (STIR) in FW testing to see if we need to emulate it.
                   May just fire off enabled interrupts in round-robin fashion. 
      6) [IMPORTANT] Do I need to switch between MSP and PSP? Still don't know how they work with the SP.
                     (Probably need to switch between the two as well.) 
                     When are they init? What does it look like when either is used? 
      7) [CURIOUS] In what context are dynamically linked ELFs used? Currently, we only create binary from statically linked.
                   Would we need to create binary from dynamically linked?                             
          

/* Compiling the Emulators */
// TODO: Eventually want to make my added files apart of the unicorn library
gcc EmulateUart.c emulatorConfig.c toml.c tester.c -lunicorn -lpthread


/* Generating ELF file: Compiling the Source Code to emulate */
arm-none-eabi-gcc -specs=nosys.specs SimpleUart.c -o SimpleUart.elf
or
arm-none-eabi-gcc -specs=nosys.specs PollingUart.c -o PollingUart.elf

/* Compiling and Making Unicorn */        
Command to install and compile Unicorn
./make.sh (assumes config file only makes for ARM)
sudo ./make.sh install

/* Setting Unicorn Library path for GCC */
1.) Undefined References to pthread functions
    - place lpthread after lunicorn
2.) Can't find libunicorn.so.1 when running executable
    - Run 'ldd a.out' to see what libraries are found and where
    - Add the path of libunicorn.so.1 to GCC library path @ /etc/ld.so.conf.d/x86_64-linux-gnu.conf
    - run sudo ldconfig to update library cache
  
/* Getting TOML to work with CPEA */
C Parser
	1) Include toml.h and toml.c files.
Python3 TOML Parser
	tomlkit
	1) pip install tomlkit 

/* Getting ELF Parsing to work with CPEA */
Python3 ELF Parser
	pyelftools
	1) pip install pyelftool  
  
  
/* Deprecated methods for getting Raw Binary to execute */ 

/* Producing Hex String from assembly */   
Assembly to Hex String
rasm2 -a arm -C -f arm.asm

/* Manually producing binaries to emulate */
Compiling C code to 32-bit ARM
To Produce Assembly:
	arm-none-eabi-gcc -marm -S (--specs=nosys.specs) SimplePollUart.c -o SimplePollUart.s
    		  	               (optional, may want to try)
To Assemble:
	arm-none-eabi-as -o SimplePollUart.o SimplePollUart.s

To Compile,assemble,link
	arm-none-eabi-gcc -marm SimplePoll_uart.c

To Print Opcode
   - Radare2 to print out opcode. Add '00' to end of file to add terminator.
      - Go to entry point with command
         'p8 [N]' to print hexpair list for N bytes and remember to add '00' string terminator
         
To Convert to Raw Binary
    - 'xxd -r -p input.opcode output.bin' to get raw binary
	  - Read this into Unicorn and store in char array. :)
	 

