"""
Things to add:
	- Argument parsing when running script.
		1) Elf File 
		2) Verbose Mode to print results
	
	- See if we ever need to calculate .text or .data size here since emulator currently handles that.
	
	- *** IMPORTANT *** Update exit addr to end of main, or find another suitable last instruction
"""

import subprocess
from tomlkit import parse
from tomlkit import dumps
from tomlkit import integer  
from tomlkit import comment
from elftools.elf.elffile import ELFFile
from elftools.elf.elffile import SymbolTableSection

# Get emulator and firmware configuration details
elf = "SimpleUart.elf"

with open(elf, 'rb') as f:
	elffile = ELFFile(f)
	
	# Get Segment Headers for memory map. Headers stored as dictionaries.
	for segment in elffile.iter_segments():	
		header = segment.header				# Get the header dictionary
		if header['p_type'] == 'PT_LOAD':
		
			# Get Exectuable Virtual Address
			if header['p_flags'] == 5:		# R E (Executable Header)
				ExecVAddr = header['p_vaddr']
				
			# Get Data Virtual Address and Size	
			elif header['p_flags'] == 6:	# RW  (Data Header)
				DataVAddr = header['p_vaddr']
				DataSize = header['p_memsz']

			
	# Calculate Total Memory Size for emulator
	fw_mem_size = ExecVAddr + DataVAddr + DataSize	# Total Size
	align = 4096 - (fw_mem_size%4096)				# Align to 4096 for unicorn
	emu_mem_size = fw_mem_size + align				# Total Emulator Memory
	
	# Get Section Headers for code and data (.text and .data). Headers stored as dictionaries.
	for section in elffile.iter_sections():
	
		# Get entry and exit points
		if isinstance(section, SymbolTableSection):
			for symbol in section.iter_symbols():
				if symbol.name == 'main':
					func_addr = symbol.entry['st_value']
					MainAddr = func_addr

				elif symbol.name == 'exit':
					func_addr = symbol.entry['st_value']
					ExitAddr = func_addr
				
		header = section.header	
		# Get .text section info (.text == 33)
		if header['sh_name'] == 33:
			TextAddr = header['sh_addr']
			TextSize = header['sh_size']
		
		# Get .data section info (.data == 98)
		elif header['sh_name'] == 98:
			DataAddr = header['sh_addr']
			DataSize = header['sh_size']
			

						
# Generate .text and .data binary files for Unicorn
elf_name = elf.split('.')				# Remove ".elf" extension from elf file
TextBin = elf_name[0] + ".code.bin"
DataBin = elf_name[0] + ".data.bin"

# .text binary
out = subprocess.run(['arm-none-eabi-objcopy', '-O', 'binary', '-j', '.text', elf, TextBin],
					   stderr=subprocess.PIPE,	# Pipe to stdout object
					   text=True)	   			# Use text and not binary
if (out.stdout):
	print("objcopy error: Couldn't produce .text binary")
	
# .data binary					   								
out = subprocess.run(['arm-none-eabi-objcopy', '-O', 'binary', '-j', '.data', elf, DataBin],
					   stderr=subprocess.PIPE,	# Pipe to stdout object
					   text=True)	   			# Use text and not binary
if (out.stdout):
	print("objcopy error: Couldn't produce .data binary")



# Print Relevant Unicorn Information extracted from ELF
print("Memory Map")
print("   Start: " + hex(ExecVAddr))
print("   Size:  " + hex(emu_mem_size))
print("\nMemory Write Information")
print("   .text Addr: " + hex(TextAddr))
print("   .text Size: " + hex(TextSize))
print("   .data Addr: " + hex(DataAddr))
print("   .data Size: " + hex(DataSize))

# NOTE: Can use the function after main() as the stopping address
print("\nEmulator Begin and Until Addresses")
print("   Begin: " + hex(MainAddr))
print("   Until: " + hex(ExitAddr))

print("\nGenerated Binary Files for Unicorn:")
print("   " + TextBin)
print("   " + DataBin)


# Update toml dictionary with ELF data

# Load entire TOML as a dictionary
config = parse(open('emulatorConfig.toml').read())

# Update flash addr
config['mem_map']['flash_addr'] = hex(ExecVAddr)
config['mem_map']['flash_addr'].comment(" Generated by emulatorSetup.py")

# Update flash size
config['mem_map']['flash_size'] = hex(emu_mem_size)
config['mem_map']['flash_size'].comment(" Generated by emulatorSetup.py")

config['mem_map']['mmio']['reg_count'] = 13

# Update .text start
config['firmware']['code']['code_addr'] = hex(TextAddr)
config['firmware']['code']['code_addr'].comment(" Generated by emulatorSetup.py")

# .text size determine by emulator at the moment.
config['firmware']['code']['code_size'] = hex(TextSize)
config['firmware']['code']['code_size'].comment(" Generated by emulatorSetup.py")

# Update .data start
config['firmware']['data']['data_addr'] = hex(DataAddr)
config['firmware']['data']['data_addr'].comment(" Generated by emulatorSetup.py")

# .data size determine by emulator at the moment.
config['firmware']['data']['data_size'] = hex(DataSize)
config['firmware']['data']['data_size'].comment(" Generated by emulatorSetup.py")

# Update entry point
config['firmware']['execution']['entry'] = hex(MainAddr)
config['firmware']['execution']['entry'].comment(" Generated by emulatorSetup.py")

# Update exit point (NOT updating since this hasn't been tested to work)
config['firmware']['execution']['end'] = hex(ExitAddr)
config['firmware']['execution']['end'].comment(" Generated by emulatorSetup.py")

# Write new configurations to a test TOML file

# Dumps the .toml file as a string while preserving formatting
config = dumps(config)
#print(config)

stop_index = config.find("mem_map.mmio.uart")

parsed_config = ""

for i in range(0, len(config)):
	if (config[i] != "\"") and (i < stop_index):
		parsed_config = parsed_config + config[i]

# Concatenate the remaining, uneditted string
parsed_config = parsed_config + config[stop_index:]
#print(parsed_config)


with open('testConfig.toml', 'w') as f:
	f.write(parsed_config)


